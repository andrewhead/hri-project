% vim:ft=tex:
%
\section{Evaluation}

\subsection{Lessons}

\subsubsection{Input Design}

To improve the efficiency of interaction with the simplex, we propose a couple of ideas.
Don't deliver the reflection, expansion and contraction all at once.
Only deliver one point at a time.
\andrew{It would be great if we could show some estimation of how much time is wasted if we show all three vs.\ showing only the necessary ones.}
Also, don't recompute the ranks after the worst point has been replaced.
As it was replaced with a suggested point, its rank should already be known.
So always return a reflection after the first ranking, unless a reduce has been performed.
Reduce operations introduce additional unseen points.

Participants shouldn't be given a choice to rank an expansion or a contraction if they won't be able to incorporate it into the current best set.
It makes the system look like it's only randomly accepting their advice.
Certain types of animations may make it more clear that one of the previously ranked points is getting substituted in.

\subsubsection{Sundry User Interface Issues}

On user (P2) expressed a preference for insertion sort instead of swap sort.

\subsection{Limitations}

Our simplex system optimizes on a logarithmic scale.
The frontend we provide for setting parameters asks users to input parameters on a linear scale.
With the simplex, we encode our personal observations and domain knowledge (that more diversity of space can be covered on a log scale).
However, one purpose of this work is to discover generic optimization methods for finding optimal user preferences.
So, we violate this purpose by incorporating this domain understanding of lognormal scales.
